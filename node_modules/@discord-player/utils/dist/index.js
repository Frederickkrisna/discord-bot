"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Collection: () => Collection,
  EventEmitter: () => import_node_events.EventEmitter,
  PlayerException: () => PlayerException,
  Queue: () => Queue,
  createEnum: () => createEnum,
  keyMirror: () => createEnum,
  version: () => version
});
module.exports = __toCommonJS(src_exports);

// src/Collection.ts
var import_collection = require("@discordjs/collection");
var _array;
var Collection = class extends import_collection.Collection {
  constructor() {
    super(...arguments);
    __privateAdd(this, _array, void 0);
  }
  array() {
    if (__privateGet(this, _array))
      return __privateGet(this, _array);
    __privateSet(this, _array, [...this.values()]);
    return __privateGet(this, _array);
  }
  set(key, value) {
    __privateSet(this, _array, null);
    super.set(key, value);
    return this;
  }
  delete(key) {
    __privateSet(this, _array, null);
    return super.delete(key);
  }
};
__name(Collection, "Collection");
_array = new WeakMap();

// src/Queue.ts
var import_util = require("util");
var Queue = class {
  constructor(strategy = "FIFO", initializer = []) {
    this.strategy = strategy;
    if (!["FIFO", "LIFO"].includes(strategy))
      throw new TypeError(`Invalid queue strategy "${strategy}"!`);
    this.store = Array.isArray(initializer) ? initializer : [];
    Object.defineProperty(this, "store", {
      writable: true,
      configurable: true,
      enumerable: false
    });
  }
  get data() {
    return this.toArray();
  }
  static from(data, strategy = "FIFO") {
    return new Queue(strategy, data);
  }
  isFIFO() {
    return this.strategy === "FIFO";
  }
  isLIFO() {
    return this.strategy === "LIFO";
  }
  add(item) {
    if (this.strategy === "FIFO") {
      if (Array.isArray(item)) {
        this.store.push(...item);
      } else {
        this.store.push(item);
      }
    } else {
      if (Array.isArray(item)) {
        this.store.unshift(...item);
      } else {
        this.store.unshift(item);
      }
    }
  }
  clear() {
    this.store = [];
  }
  shuffle() {
    for (let i = this.store.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [this.store[i], this.store[j]] = [this.store[j], this.store[i]];
    }
  }
  remove(itemFilter) {
    const items = this.store.filter(itemFilter);
    if (items.length)
      this.store = this.store.filter((res) => !items.includes(res));
  }
  removeOne(itemFilter) {
    const item = this.store.findIndex(itemFilter);
    if (item > -1)
      this.store.splice(item, 1);
  }
  find(itemFilter) {
    return this.store.find(itemFilter);
  }
  filter(itemFilter) {
    return this.store.filter(itemFilter);
  }
  some(itemFilter) {
    return this.store.some(itemFilter);
  }
  every(itemFilter) {
    return this.store.every(itemFilter);
  }
  map(itemFilter) {
    const arr = this.toArray();
    return arr.map(itemFilter);
  }
  at(idx) {
    const arr = this.toArray();
    return typeof Array.prototype.at === "function" ? arr.at(idx) : arr[idx];
  }
  dispatch() {
    return this.store.shift();
  }
  clone() {
    return new Queue(this.strategy, this.store.slice());
  }
  get size() {
    return this.store.length;
  }
  toString() {
    return `Queue<${this.store.length} items>`;
  }
  toArray() {
    return this.store.slice();
  }
  toJSON() {
    return this.store;
  }
  [import_util.inspect.custom]() {
    return `${this.constructor.name} {
  strategy: '${this.strategy}',
  data: ${(0, import_util.inspect)(this.data, {
      showHidden: false,
      colors: true,
      depth: 1,
      maxArrayLength: 5
    })}
}`;
  }
};
__name(Queue, "Queue");

// src/EventEmitter.ts
var import_node_events = require("events");

// src/utils.ts
function createEnum(data) {
  const obj = {};
  for (const item of data)
    obj[item] = item;
  return Object.freeze(obj);
}
__name(createEnum, "createEnum");

// src/Errors.ts
var PlayerException = class extends Error {
  constructor(message) {
    super(typeof message === "string" ? message : JSON.stringify(message, null, 2));
  }
};
__name(PlayerException, "PlayerException");

// src/index.ts
var version = "0.2.2";
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Collection,
  EventEmitter,
  PlayerException,
  Queue,
  createEnum,
  keyMirror,
  version
});
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vc3JjL2luZGV4LnRzIiwgIi4uL3NyYy9Db2xsZWN0aW9uLnRzIiwgIi4uL3NyYy9RdWV1ZS50cyIsICIuLi9zcmMvRXZlbnRFbWl0dGVyLnRzIiwgIi4uL3NyYy91dGlscy50cyIsICIuLi9zcmMvRXJyb3JzLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJleHBvcnQgKiBmcm9tICcuL0NvbGxlY3Rpb24nO1xuZXhwb3J0ICogZnJvbSAnLi9RdWV1ZSc7XG5leHBvcnQgKiBmcm9tICcuL0V2ZW50RW1pdHRlcic7XG5leHBvcnQgKiBmcm9tICcuL3V0aWxzJztcbmV4cG9ydCAqIGZyb20gJy4vRXJyb3JzJztcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1pbmZlcnJhYmxlLXR5cGVzXG5leHBvcnQgY29uc3QgdmVyc2lvbjogc3RyaW5nID0gJzAuMi4yJztcbiIsICJpbXBvcnQgeyBDb2xsZWN0aW9uIGFzIENvbGxlY3Rpb25OYXRpdmUsIEtlZXAsIFJlYWRvbmx5Q29sbGVjdGlvbiB9IGZyb20gJ0BkaXNjb3JkanMvY29sbGVjdGlvbic7XG5cbmV4cG9ydCBjbGFzcyBDb2xsZWN0aW9uPEsgPSB1bmtub3duLCBWID0gdW5rbm93bj4gZXh0ZW5kcyBDb2xsZWN0aW9uTmF0aXZlPEssIFY+IHtcbiAgICAjYXJyYXkhOiBWW10gfCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FycmF5PFY+fSBBcnJheSBvZiB0aGlzIGNvbGxlY3Rpb25cbiAgICAgKi9cbiAgICBwdWJsaWMgYXJyYXkoKTogVltdIHtcbiAgICAgICAgaWYgKHRoaXMuI2FycmF5KSByZXR1cm4gdGhpcy4jYXJyYXk7XG4gICAgICAgIHRoaXMuI2FycmF5ID0gWy4uLnRoaXMudmFsdWVzKCldO1xuICAgICAgICByZXR1cm4gdGhpcy4jYXJyYXk7XG4gICAgfVxuXG4gICAgcHVibGljIHNldChrZXk6IEssIHZhbHVlOiBWKTogdGhpcyB7XG4gICAgICAgIHRoaXMuI2FycmF5ID0gbnVsbDtcbiAgICAgICAgc3VwZXIuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBwdWJsaWMgZGVsZXRlKGtleTogSyk6IGJvb2xlYW4ge1xuICAgICAgICB0aGlzLiNhcnJheSA9IG51bGw7XG4gICAgICAgIHJldHVybiBzdXBlci5kZWxldGUoa2V5KTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgaW5zcGVjdCB9IGZyb20gJ3V0aWwnO1xuXG5leHBvcnQgdHlwZSBRdWV1ZVN0cmF0ZWd5ID0gJ0xJRk8nIHwgJ0ZJRk8nO1xuXG5leHBvcnQgdHlwZSBRdWV1ZUl0ZW1GaWx0ZXI8VCwgUiA9IGJvb2xlYW4+ID0gKHZhbHVlOiBULCBpZHg6IG51bWJlciwgYXJyYXk6IFRbXSkgPT4gUjtcblxuZXhwb3J0IGNsYXNzIFF1ZXVlPFQgPSB1bmtub3duPiB7XG4gICAgcHVibGljIHN0b3JlOiBUW107XG4gICAgcHVibGljIGNvbnN0cnVjdG9yKHB1YmxpYyBzdHJhdGVneTogUXVldWVTdHJhdGVneSA9ICdGSUZPJywgaW5pdGlhbGl6ZXI6IFRbXSA9IFtdKSB7XG4gICAgICAgIGlmICghWydGSUZPJywgJ0xJRk8nXS5pbmNsdWRlcyhzdHJhdGVneSkpIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgcXVldWUgc3RyYXRlZ3kgXCIke3N0cmF0ZWd5fVwiIWApO1xuICAgICAgICB0aGlzLnN0b3JlID0gQXJyYXkuaXNBcnJheShpbml0aWFsaXplcikgPyBpbml0aWFsaXplciA6IFtdO1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc3RvcmUnLCB7XG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9BcnJheSgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgZnJvbTxUPihkYXRhOiBUW10sIHN0cmF0ZWd5OiBRdWV1ZVN0cmF0ZWd5ID0gJ0ZJRk8nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUXVldWU8VD4oc3RyYXRlZ3ksIGRhdGEpO1xuICAgIH1cblxuICAgIHB1YmxpYyBpc0ZJRk8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmF0ZWd5ID09PSAnRklGTyc7XG4gICAgfVxuXG4gICAgcHVibGljIGlzTElGTygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyYXRlZ3kgPT09ICdMSUZPJztcbiAgICB9XG5cbiAgICBwdWJsaWMgYWRkKGl0ZW06IFQgfCBUW10pIHtcbiAgICAgICAgaWYgKHRoaXMuc3RyYXRlZ3kgPT09ICdGSUZPJykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JlLnB1c2goLi4uaXRlbSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcmUucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yZS51bnNoaWZ0KC4uLml0ZW0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JlLnVuc2hpZnQoaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuc3RvcmUgPSBbXTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2h1ZmZsZSgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc3RvcmUubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3QgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChpICsgMSkpO1xuICAgICAgICAgICAgW3RoaXMuc3RvcmVbaV0sIHRoaXMuc3RvcmVbal1dID0gW3RoaXMuc3RvcmVbal0sIHRoaXMuc3RvcmVbaV1dO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIHJlbW92ZShpdGVtRmlsdGVyOiBRdWV1ZUl0ZW1GaWx0ZXI8VD4pIHtcbiAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLnN0b3JlLmZpbHRlcihpdGVtRmlsdGVyKTtcbiAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCkgdGhpcy5zdG9yZSA9IHRoaXMuc3RvcmUuZmlsdGVyKChyZXMpID0+ICFpdGVtcy5pbmNsdWRlcyhyZXMpKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgcmVtb3ZlT25lKGl0ZW1GaWx0ZXI6IFF1ZXVlSXRlbUZpbHRlcjxUPikge1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5zdG9yZS5maW5kSW5kZXgoaXRlbUZpbHRlcik7XG4gICAgICAgIGlmIChpdGVtID4gLTEpIHRoaXMuc3RvcmUuc3BsaWNlKGl0ZW0sIDEpO1xuICAgIH1cblxuICAgIHB1YmxpYyBmaW5kKGl0ZW1GaWx0ZXI6IFF1ZXVlSXRlbUZpbHRlcjxUPikge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZS5maW5kKGl0ZW1GaWx0ZXIpO1xuICAgIH1cblxuICAgIHB1YmxpYyBmaWx0ZXIoaXRlbUZpbHRlcjogUXVldWVJdGVtRmlsdGVyPFQ+KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JlLmZpbHRlcihpdGVtRmlsdGVyKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc29tZShpdGVtRmlsdGVyOiBRdWV1ZUl0ZW1GaWx0ZXI8VD4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmUuc29tZShpdGVtRmlsdGVyKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZXZlcnkoaXRlbUZpbHRlcjogUXVldWVJdGVtRmlsdGVyPFQ+KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JlLmV2ZXJ5KGl0ZW1GaWx0ZXIpO1xuICAgIH1cblxuICAgIHB1YmxpYyBtYXA8UiA9IFQ+KGl0ZW1GaWx0ZXI6IFF1ZXVlSXRlbUZpbHRlcjxULCBSPikge1xuICAgICAgICBjb25zdCBhcnIgPSB0aGlzLnRvQXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIGFyci5tYXAoaXRlbUZpbHRlcik7XG4gICAgfVxuXG4gICAgcHVibGljIGF0KGlkeDogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IHRoaXMudG9BcnJheSgpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIEFycmF5LnByb3RvdHlwZS5hdCA9PT0gJ2Z1bmN0aW9uJyA/IGFyci5hdChpZHgpIDogYXJyW2lkeF07XG4gICAgfVxuXG4gICAgcHVibGljIGRpc3BhdGNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZS5zaGlmdCgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBRdWV1ZSh0aGlzLnN0cmF0ZWd5LCB0aGlzLnN0b3JlLnNsaWNlKCkpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmUubGVuZ3RoO1xuICAgIH1cblxuICAgIHB1YmxpYyB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBRdWV1ZTwke3RoaXMuc3RvcmUubGVuZ3RofSBpdGVtcz5gO1xuICAgIH1cblxuICAgIHB1YmxpYyB0b0FycmF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZS5zbGljZSgpO1xuICAgIH1cblxuICAgIHB1YmxpYyB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JlO1xuICAgIH1cblxuICAgIHB1YmxpYyBbaW5zcGVjdC5jdXN0b21dKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSB7XFxuICBzdHJhdGVneTogJyR7dGhpcy5zdHJhdGVneX0nLFxcbiAgZGF0YTogJHtpbnNwZWN0KHRoaXMuZGF0YSwge1xuICAgICAgICAgICAgc2hvd0hpZGRlbjogZmFsc2UsXG4gICAgICAgICAgICBjb2xvcnM6IHRydWUsXG4gICAgICAgICAgICBkZXB0aDogMSxcbiAgICAgICAgICAgIG1heEFycmF5TGVuZ3RoOiA1XG4gICAgICAgIH0pfVxcbn1gO1xuICAgIH1cbn1cbiIsICJleHBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdub2RlOmV2ZW50cyc7XG4iLCAiZnVuY3Rpb24gY3JlYXRlRW51bTxLIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyIHwgc3ltYm9sPihkYXRhOiBLW10pIHtcbiAgICBjb25zdCBvYmogPSB7fSBhcyBSZWNvcmQ8SywgSz47XG5cbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgZGF0YSkgb2JqW2l0ZW1dID0gaXRlbTtcblxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKG9iaik7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZUVudW0sIGNyZWF0ZUVudW0gYXMga2V5TWlycm9yIH07XG4iLCAiZXhwb3J0IHR5cGUgUGxheWVyRXhjZXB0aW9uTWVzc2FnZSA9IHN0cmluZyB8IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuXG5leHBvcnQgY2xhc3MgUGxheWVyRXhjZXB0aW9uIGV4dGVuZHMgRXJyb3Ige1xuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihtZXNzYWdlOiBQbGF5ZXJFeGNlcHRpb25NZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJyA/IG1lc3NhZ2UgOiBKU09OLnN0cmluZ2lmeShtZXNzYWdlLCBudWxsLCAyKSk7XG4gICAgfVxufVxuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtB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SyxVQUFVO0FBQUEsRUFDckM7QUFBQSxFQUVPLE9BQU8sWUFBZ0M7QUFDMUMsV0FBTyxLQUFLLE1BQU0sT0FBTyxVQUFVO0FBQUEsRUFDdkM7QUFBQSxFQUVPLEtBQUssWUFBZ0M7QUFDeEMsV0FBTyxLQUFLLE1BQU0sS0FBSyxVQUFVO0FBQUEsRUFDckM7QUFBQSxFQUVPLE1BQU0sWUFBZ0M7QUFDekMsV0FBTyxLQUFLLE1BQU0sTUFBTSxVQUFVO0FBQUEsRUFDdEM7QUFBQSxFQUVPLElBQVcsWUFBbUM7QUFDakQsVUFBTSxNQUFNLEtBQUssUUFBUTtBQUN6QixXQUFPLElBQUksSUFBSSxVQUFVO0FBQUEsRUFDN0I7QUFBQSxFQUVPLEdBQUcsS0FBYTtBQUNuQixVQUFNLE1BQU0sS0FBSyxRQUFRO0FBQ3pCLFdBQU8sT0FBTyxNQUFNLFVBQVUsT0FBTyxhQUFhLElBQUksR0FBRyxHQUFHLElBQUksSUFBSTtBQUFBLEVBQ3hFO0FBQUEsRUFFTyxXQUFXO0FBQ2QsV0FBTyxLQUFLLE1BQU0sTUFBTTtBQUFBLEVBQzVCO0FBQUEsRUFFTyxRQUFRO0FBQ1gsV0FBTyxJQUFJLE1BQU0sS0FBSyxVQUFVLEtBQUssTUFBTSxNQUFNLENBQUM7QUFBQSxFQUN0RDtBQUFBLEVBRUEsSUFBVyxPQUFPO0FBQ2QsV0FBTyxLQUFLLE1BQU07QUFBQSxFQUN0QjtBQUFBLEVBRU8sV0FBVztBQUNkLFdBQU8sU0FBUyxLQUFLLE1BQU07QUFBQSxFQUMvQjtBQUFBLEVBRU8sVUFBVTtBQUNiLFdBQU8sS0FBSyxNQUFNLE1BQU07QUFBQSxFQUM1QjtBQUFBLEVBRU8sU0FBUztBQUNaLFdBQU8sS0FBSztBQUFBLEVBQ2hCO0FBQUEsRUFFQSxDQUFRLG9CQUFRLFVBQVU7QUFDdEIsV0FBTyxHQUFHLEtBQUssWUFBWTtBQUFBLGVBQXdCLEtBQUs7QUFBQSxjQUF1QixxQkFBUSxLQUFLLE1BQU07QUFBQSxNQUM5RixZQUFZO0FBQUEsTUFDWixRQUFRO0FBQUEsTUFDUixPQUFPO0FBQUEsTUFDUCxnQkFBZ0I7QUFBQSxJQUNwQixDQUFDO0FBQUE7QUFBQSxFQUNMO0FBQ0o7QUE1SGE7OztBQ05iLHlCQUE2Qjs7O0FDQTdCLFNBQVMsV0FBK0MsTUFBVztBQUMvRCxRQUFNLE1BQU0sQ0FBQztBQUViLGFBQVcsUUFBUTtBQUFNLFFBQUksUUFBUTtBQUVyQyxTQUFPLE9BQU8sT0FBTyxHQUFHO0FBQzVCO0FBTlM7OztBQ0VGLElBQU0sa0JBQU4sY0FBOEIsTUFBTTtBQUFBLEVBQ2hDLFlBQVksU0FBaUM7QUFDaEQsVUFBTSxPQUFPLFlBQVksV0FBVyxVQUFVLEtBQUssVUFBVSxTQUFTLE1BQU0sQ0FBQyxDQUFDO0FBQUEsRUFDbEY7QUFDSjtBQUphOzs7QUxLTixJQUFNLFVBQWtCOyIsCiAgIm5hbWVzIjogWyJDb2xsZWN0aW9uTmF0aXZlIl0KfQo=