import { BaseExtractor, SearchQueryType, Track, GuildQueueHistory, ExtractorInfo, ExtractorSearchContext, ExtractorStreamable, ExtractorExecutionContext } from 'discord-player';
import * as SoundCloud from 'soundcloud.ts';
import { SoundcloudTrackV2 } from 'soundcloud.ts';
import * as youtube_sr from 'youtube-sr';
import { Video } from 'youtube-sr';
import * as stream from 'stream';
import { Readable } from 'stream';
import { Client } from 'genius-lyrics';
import * as fs from 'fs';
import { HTMLElement } from 'node-html-parser';
import { RequestOptions } from 'http';

interface SoundCloudExtractorInit {
    clientId?: string;
    oauthToken?: string;
    proxy?: string;
}
declare class SoundCloudExtractor extends BaseExtractor<SoundCloudExtractorInit> {
    static identifier: "com.discord-player.soundcloudextractor";
    static instance: SoundCloudExtractor | null;
    internal: SoundCloud.Soundcloud;
    activate(): Promise<void>;
    deactivate(): Promise<void>;
    validate(query: string, type?: SearchQueryType | null | undefined): Promise<boolean>;
    getRelatedTracks(track: Track, history: GuildQueueHistory): Promise<ExtractorInfo>;
    handle(query: string, context: ExtractorSearchContext): Promise<ExtractorInfo>;
    emptyResponse(): ExtractorInfo;
    stream(info: Track): Promise<string>;
}

declare const createImport: (lib: string) => Promise<any>;
declare const UA = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36 Edg/109.0.1518.49";
declare const fetch: typeof globalThis.fetch;
declare const YouTubeLibs: string[];
type StreamFN = (q: string, ext: BaseExtractor, demuxable?: boolean) => Promise<stream.Readable | string | {
    stream: stream.Readable;
    $fmt: string;
}>;
declare function loadYtdl(options?: any, force?: boolean): Promise<{
    name: string;
    stream: StreamFN;
    lib: string;
}>;
declare function makeYTSearch(query: string, opt: any): Promise<youtube_sr.Video[]>;
declare function makeSCSearch(query: string): Promise<SoundCloud.SoundcloudTrackV2[]>;
declare function pullYTMetadata(ext: BaseExtractor, info: Track): Promise<youtube_sr.Video | null>;
declare function pullSCMetadata(ext: BaseExtractor, info: Track): Promise<SoundCloud.SoundcloudTrackV2 | null>;
declare function filterSoundCloudPreviews(tracks: SoundCloud.SoundcloudTrackV2[]): SoundCloud.SoundcloudTrackV2[];

interface YoutubeExtractorInit {
    createStream?: (ext: YoutubeExtractor, url: string) => Promise<Readable | string>;
}
declare class YoutubeExtractor extends BaseExtractor<YoutubeExtractorInit> {
    static identifier: "com.discord-player.youtubeextractor";
    _stream: StreamFN;
    _ytLibName: string;
    static instance: YoutubeExtractor | null;
    activate(): Promise<void>;
    deactivate(): Promise<void>;
    validate(query: string, type?: SearchQueryType | null | undefined): Promise<boolean>;
    handle(query: string, context: ExtractorSearchContext): Promise<ExtractorInfo>;
    private _makeYTSearch;
    getRelatedTracks(track: Track, history: GuildQueueHistory): Promise<ExtractorInfo>;
    emptyResponse(): ExtractorInfo;
    stream(info: Track): Promise<ExtractorStreamable>;
    static validateURL(link: string): boolean;
    static validateId(id: string): boolean;
    static parseURL(link: string): string;
}

declare function lyricsExtractor(apiKey?: string, force?: boolean): {
    search: typeof search;
    client: Client;
};
declare function search(query: string): Promise<LyricsData | null>;
interface LyricsData {
    title: string;
    fullTitle: string;
    id: number;
    thumbnail: string;
    image: string;
    url: string;
    artist: {
        name: string;
        id: number;
        url: string;
        image: string;
    };
    lyrics: string;
}

declare class VimeoExtractor extends BaseExtractor {
    static identifier: "com.discord-player.vimeoextractor";
    validate(query: string, type?: SearchQueryType | null | undefined): Promise<boolean>;
    getRelatedTracks(track: Track): Promise<ExtractorInfo>;
    handle(query: string, context: ExtractorSearchContext): Promise<ExtractorInfo>;
    emptyResponse(): ExtractorInfo;
    stream(info: Track): Promise<string>;
}

declare class ReverbnationExtractor extends BaseExtractor {
    static identifier: "com.discord-player.reverbnationextractor";
    validate(query: string, type?: SearchQueryType | null | undefined): Promise<boolean>;
    getRelatedTracks(track: Track): Promise<ExtractorInfo>;
    handle(query: string, context: ExtractorSearchContext): Promise<ExtractorInfo>;
    emptyResponse(): ExtractorInfo;
    stream(info: Track): Promise<string>;
}

declare class AttachmentExtractor extends BaseExtractor {
    static identifier: "com.discord-player.attachmentextractor";
    priority: number;
    validate(query: string, type?: SearchQueryType | null | undefined): Promise<boolean>;
    getRelatedTracks(track: Track): Promise<ExtractorInfo>;
    handle(query: string, context: ExtractorSearchContext): Promise<ExtractorInfo>;
    emptyResponse(): ExtractorInfo;
    stream(info: Track): Promise<string | fs.ReadStream>;
}

declare enum BridgeSource {
    /**
     * Automatically resolve the bridge source
     */
    Auto = "auto",
    /**
     * Use SoundCloud as the bridge source
     */
    SoundCloud = "soundcloud",
    /**
     * Use YouTube as the bridge source
     */
    YouTube = "youtube"
}
type IBridgeSource = 'soundcloud' | 'youtube' | 'auto';
declare class BridgeProvider {
    bridgeSource: BridgeSource;
    constructor(source: IBridgeSource);
    setBridgeSource(source: BridgeSource | IBridgeSource): void;
    isSoundCloud(): boolean;
    isYouTube(): boolean;
    isAuto(): boolean;
    resolveProvider(): BridgeSource;
    resolve(ext: BaseExtractor, track: Track): Promise<BridgedMetadata>;
    stream(meta: BridgedMetadata): Promise<string | stream.Readable | {
        stream: stream.Readable;
        $fmt: string;
    }>;
}
interface BridgedMetadata {
    source: IBridgeSource;
    data: SoundcloudTrackV2 | Video | null;
}
declare const defaultBridgeProvider: BridgeProvider;
declare const createBridgeProvider: (source: BridgeSource) => BridgeProvider;

interface BridgedOption {
    bridgeProvider?: BridgeProvider;
}
declare class BridgedExtractor<T extends BridgedOption> extends BaseExtractor<T> {
    constructor(context: ExtractorExecutionContext, options?: T | undefined);
    setBridgeProvider(provider: BridgeProvider): void;
    setBridgeProviderSource(source: BridgeSource | IBridgeSource): void;
    get bridgeProvider(): BridgeProvider;
}

interface AppleMusicExtractorInit {
    createStream?: (ext: AppleMusicExtractor, url: string) => Promise<Readable | string>;
    bridgeProvider?: BridgeProvider;
}
declare class AppleMusicExtractor extends BridgedExtractor<AppleMusicExtractorInit> {
    static identifier: "com.discord-player.applemusicextractor";
    private _stream;
    activate(): Promise<void>;
    deactivate(): Promise<void>;
    validate(query: string, type?: SearchQueryType | null | undefined): Promise<boolean>;
    getRelatedTracks(track: Track, history: GuildQueueHistory): Promise<ExtractorInfo>;
    handle(query: string, context: ExtractorSearchContext): Promise<ExtractorInfo>;
    stream(info: Track): Promise<ExtractorStreamable>;
}

declare class AppleMusic {
    constructor();
    static search(query: string): Promise<any>;
    static getSongInfoFallback(res: HTMLElement, name: string, id: string, link: string): Promise<{
        id: string;
        duration: string;
        title: string;
        url: string;
        thumbnail: string;
        artist: {
            name: string;
        };
    } | null>;
    static getSongInfo(link: string): Promise<{
        id: any;
        duration: any;
        title: any;
        url: any;
        thumbnail: string;
        artist: {
            name: any;
        };
    } | null>;
    static getPlaylistInfo(link: string): Promise<{
        id: any;
        title: any;
        thumbnail: string;
        artist: {
            name: any;
        };
        url: any;
        tracks: any;
    } | null>;
    static getAlbumInfo(link: string): Promise<{
        id: any;
        title: any;
        thumbnail: string;
        artist: {
            name: any;
        };
        url: any;
        tracks: any;
    } | null>;
}

declare class Vimeo {
    constructor();
    /**
     * @typedef {Readable} Readable
     */
    /**
     * Downloads from vimeo
     * @param {number} id Vimeo video id
     * @returns {Promise<Readable>}
     */
    static download(id: number | string): Promise<Readable>;
    /**
     * Returns video info
     * @param {number} id Video id
     */
    static getInfo(id: number | string): Promise<VimeoInfo | null>;
}
interface VimeoInfo {
    id: number;
    duration: number;
    title: string;
    url: string;
    thumbnail: string;
    stream: string;
    author: {
        id: number;
        name: string;
        url: string;
        avatar: string;
    };
}

declare function downloadStream(url: string, opts?: RequestOptions): Promise<Readable>;

interface SP_ACCESS_TOKEN {
    token: string;
    expiresAfter: number;
    type: 'Bearer';
}
declare class SpotifyAPI {
    credentials: {
        clientId: string | null;
        clientSecret: string | null;
    };
    accessToken: SP_ACCESS_TOKEN | null;
    constructor(credentials?: {
        clientId: string | null;
        clientSecret: string | null;
    });
    get authorizationKey(): string | null;
    requestToken(): Promise<{
        token: string;
        expiresAfter: number;
        type: "Bearer";
    } | null>;
    requestAnonymousToken(): Promise<{
        token: string;
        expiresAfter: number;
        type: "Bearer";
    } | null>;
    isTokenExpired(): boolean;
    search(query: string): Promise<{
        title: string;
        duration: number;
        artist: string;
        url: string;
        thumbnail: string | null;
    }[] | null>;
    getPlaylist(id: string): Promise<{
        name: string;
        author: string;
        thumbnail: string | null;
        id: string;
        url: string;
        tracks: {
            title: string;
            duration: number;
            artist: string;
            url: string;
            thumbnail: string | null;
        }[];
    } | null>;
    getAlbum(id: string): Promise<{
        name: string;
        author: string;
        thumbnail: string | null;
        id: string;
        url: string;
        tracks: {
            title: string;
            duration: number;
            artist: string;
            url: string;
            thumbnail: string | null;
        }[];
    } | null>;
}
interface SpotifyTrack {
    album: {
        images: {
            height: number;
            url: string;
            width: number;
        }[];
    };
    artists: {
        id: string;
        name: string;
    }[];
    duration_ms: number;
    explicit: boolean;
    external_urls: {
        spotify: string;
    };
    id: string;
    name: string;
}

type index_AppleMusic = AppleMusic;
declare const index_AppleMusic: typeof AppleMusic;
type index_SpotifyAPI = SpotifyAPI;
declare const index_SpotifyAPI: typeof SpotifyAPI;
type index_SpotifyTrack = SpotifyTrack;
type index_Vimeo = Vimeo;
declare const index_Vimeo: typeof Vimeo;
type index_VimeoInfo = VimeoInfo;
declare const index_downloadStream: typeof downloadStream;
declare namespace index {
  export {
    index_AppleMusic as AppleMusic,
    index_SpotifyAPI as SpotifyAPI,
    index_SpotifyTrack as SpotifyTrack,
    index_Vimeo as Vimeo,
    index_VimeoInfo as VimeoInfo,
    index_downloadStream as downloadStream,
  };
}

interface SpotifyExtractorInit {
    clientId?: string | null;
    clientSecret?: string | null;
    createStream?: (ext: SpotifyExtractor, url: string) => Promise<Readable | string>;
    bridgeProvider?: BridgeProvider;
}
declare class SpotifyExtractor extends BridgedExtractor<SpotifyExtractorInit> {
    static identifier: "com.discord-player.spotifyextractor";
    private _stream;
    private _lib;
    private _credentials;
    internal: SpotifyAPI;
    activate(): Promise<void>;
    deactivate(): Promise<void>;
    validate(query: string, type?: SearchQueryType | null | undefined): Promise<boolean>;
    getRelatedTracks(track: Track): Promise<ExtractorInfo>;
    handle(query: string, context: ExtractorSearchContext): Promise<ExtractorInfo>;
    stream(info: Track): Promise<ExtractorStreamable>;
    parse(q: string): {
        queryType: string;
        id: string;
    };
}

declare const version: string;

export { AppleMusicExtractor, AppleMusicExtractorInit, AttachmentExtractor, BridgeProvider, BridgeSource, BridgedExtractor, BridgedOption, IBridgeSource, index as Internal, LyricsData, ReverbnationExtractor, SoundCloudExtractor, SoundCloudExtractorInit, SpotifyExtractor, SpotifyExtractorInit, StreamFN, UA, VimeoExtractor, YoutubeExtractor as YouTubeExtractor, YouTubeLibs, YoutubeExtractor, YoutubeExtractorInit, createBridgeProvider, createImport, defaultBridgeProvider, fetch, filterSoundCloudPreviews, loadYtdl, lyricsExtractor, makeSCSearch, makeYTSearch, pullSCMetadata, pullYTMetadata, version };
