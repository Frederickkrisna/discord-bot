import { Transform, TransformCallback } from 'stream';

type IEncoder = {
    new (rate: number, channels: number, application: number): {
        encode(buffer: Buffer): Buffer;
        encode(buffer: Buffer, frameSize: number): Buffer;
        encode(buffer: Buffer, frameSize?: number): Buffer;
        decode(buffer: Buffer): Buffer;
        decode(buffer: Buffer, frameSize: number): Buffer;
        decode(buffer: Buffer, frameSize?: number): Buffer;
        applyEncoderCTL?(ctl: number, value: number): void;
        encoderCTL?(ctl: number, value: number): void;
        delete?(): void;
    };
    Application?: any;
};
type IMod = [
    string,
    (mod: any) => {
        Encoder: IEncoder;
    }
];
declare const CTL: {
    readonly BITRATE: 4002;
    readonly FEC: 4012;
    readonly PLP: 4014;
};
declare const OPUS_MOD_REGISTRY: IMod[];
interface IOpusStreamInit {
    frameSize: number;
    channels: number;
    rate: number;
    application?: number;
}
/**
 * Takes a stream of Opus data and outputs a stream of PCM data, or the inverse.
 * **You shouldn't directly instantiate this class, see opus.Encoder and opus.Decoder instead!**
 * @memberof opus
 * @extends TransformStream
 * @protected
 */
declare class OpusStream extends Transform {
    encoder: InstanceType<IEncoder> | null;
    _options: IOpusStreamInit;
    _required: number;
    /**
     * Creates a new Opus transformer.
     * @private
     * @memberof opus
     * @param {Object} [options] options that you would pass to a regular Transform stream
     */
    constructor(options?: IOpusStreamInit);
    _encode(buffer: Buffer): Buffer;
    _decode(buffer: Buffer): Buffer;
    /**
     * Returns the Opus module being used - `mediaplex`, `opusscript`, `node-opus`, or `@discordjs/opus`.
     * @type {string}
     * @readonly
     * @example
     * console.log(`Using Opus module ${prism.opus.Encoder.type}`);
     */
    static get type(): string | undefined;
    /**
     * Sets the bitrate of the stream.
     * @param {number} bitrate the bitrate to use use, e.g. 48000
     * @public
     */
    setBitrate(bitrate: number): void;
    /**
     * Enables or disables forward error correction.
     * @param {boolean} enabled whether or not to enable FEC.
     * @public
     */
    setFEC(enabled: boolean): void;
    /**
     * Sets the expected packet loss over network transmission.
     * @param {number} [percentage] a percentage (represented between 0 and 1)
     */
    setPLP(percentage: number): void;
    _final(cb: () => void): void;
    _destroy(err: Error | null, cb: (err: Error | null) => void): void;
    /**
     * Cleans up the Opus stream when it is no longer needed
     * @private
     */
    _cleanup(): void;
}
/**
 * An Opus encoder stream.
 *
 * Outputs opus packets in [object mode.](https://nodejs.org/api/stream.html#stream_object_mode)
 * @extends opus.OpusStream
 * @memberof opus
 * @example
 * const encoder = new prism.opus.Encoder({ frameSize: 960, channels: 2, rate: 48000 });
 * pcmAudio.pipe(encoder);
 * // encoder will now output Opus-encoded audio packets
 */
declare class OpusEncoder extends OpusStream {
    _buffer: Buffer;
    /**
     * Creates a new Opus encoder stream.
     * @memberof opus
     * @param {Object} options options that you would pass to a regular OpusStream, plus a few more:
     * @param {number} options.frameSize the frame size in bytes to use (e.g. 960 for stereo audio at 48KHz with a frame
     * duration of 20ms)
     * @param {number} options.channels the number of channels to use
     * @param {number} options.rate the sampling rate in Hz
     */
    constructor(options?: IOpusStreamInit);
    _transform(newChunk: Buffer, encoding: BufferEncoding, done: TransformCallback): void;
    _destroy(err: Error, cb: (err: Error | null) => void): void;
}
/**
 * An Opus decoder stream.
 *
 * Note that any stream you pipe into this must be in
 * [object mode](https://nodejs.org/api/stream.html#stream_object_mode) and should output Opus packets.
 * @extends opus.OpusStream
 * @memberof opus
 * @example
 * const decoder = new prism.opus.Decoder({ frameSize: 960, channels: 2, rate: 48000 });
 * input.pipe(decoder);
 * // decoder will now output PCM audio
 */
declare class OpusDecoder extends OpusStream {
    _transform(chunk: Buffer, encoding: BufferEncoding, done: (e?: Error | null, chunk?: Buffer) => void): void;
}
declare const version: string;

export { CTL, IEncoder, IOpusStreamInit, OPUS_MOD_REGISTRY, OpusDecoder, OpusEncoder, OpusStream, version };
