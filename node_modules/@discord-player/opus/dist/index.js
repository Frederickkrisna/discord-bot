"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  CTL: () => CTL,
  OPUS_MOD_REGISTRY: () => OPUS_MOD_REGISTRY,
  OpusDecoder: () => OpusDecoder,
  OpusEncoder: () => OpusEncoder,
  OpusStream: () => OpusStream,
  version: () => version
});
module.exports = __toCommonJS(src_exports);
var import_stream = require("stream");
var loadModule = /* @__PURE__ */ __name((modules) => {
  const errors = [];
  for (const [name, fn] of modules) {
    try {
      return {
        ...fn(require(name)),
        name
      };
    } catch (e) {
      errors.push(`Failed to load ${name}: ${e}`);
      continue;
    }
  }
  throw new Error(`Could not load opus module, tried ${modules.length} different modules. Errors: ${errors.join("\n")}`);
}, "loadModule");
var CTL = {
  BITRATE: 4002,
  FEC: 4012,
  PLP: 4014
};
var OPUS_MOD_REGISTRY = [
  [
    "mediaplex",
    (mod) => {
      if (!mod.OpusEncoder)
        throw new Error("Unsupported mediaplex version");
      return { Encoder: mod.OpusEncoder };
    }
  ],
  ["@discordjs/opus", (opus) => ({ Encoder: opus.OpusEncoder })],
  ["opusscript", (opus) => ({ Encoder: opus })],
  [
    "@evan/opus",
    (opus) => {
      const { Encoder, Decoder } = opus;
      class OpusEncoder2 {
        constructor(_rate, _channels, _application) {
          this._rate = _rate;
          this._channels = _channels;
          this._application = _application;
        }
        _ensureEncoder() {
          if (this._encoder)
            return;
          this._encoder = new Encoder({
            channels: this._channels,
            sample_rate: this._rate,
            application: {
              2048: "voip",
              2049: "audio",
              2051: "restricted_lowdelay"
            }[this._application]
          });
        }
        _ensureDecoder() {
          if (this._decoder)
            return;
          this._decoder = new Decoder({
            channels: this._channels,
            sample_rate: this._rate
          });
        }
        encode(buffer) {
          this._ensureEncoder();
          return Buffer.from(this._encoder.encode(buffer));
        }
        decode(buffer) {
          this._ensureDecoder();
          return Buffer.from(this._decoder.decode(buffer));
        }
        applyEncoderCTL(ctl, value) {
          this._ensureEncoder();
          this._encoder.ctl(ctl, value);
        }
        delete() {
          this._encoder = null;
          this._decoder = null;
        }
      }
      __name(OpusEncoder2, "OpusEncoder");
      return { Encoder: OpusEncoder2 };
    }
  ],
  ["node-opus", (opus) => ({ Encoder: opus.OpusEncoder })]
];
var Opus = {};
function loadOpus(refresh = false) {
  if (Opus.Encoder && !refresh)
    return Opus;
  Opus = loadModule(OPUS_MOD_REGISTRY);
  return Opus;
}
__name(loadOpus, "loadOpus");
var charCode = /* @__PURE__ */ __name((x) => x.charCodeAt(0), "charCode");
var OPUS_HEAD = Buffer.from([..."OpusHead"].map(charCode));
var OPUS_TAGS = Buffer.from([..."OpusTags"].map(charCode));
var OpusStream = class extends import_stream.Transform {
  constructor(options = {}) {
    if (!loadOpus().Encoder) {
      throw Error(`Could not find an Opus module! Please install one of ${OPUS_MOD_REGISTRY.map((o) => o[0]).join(", ")}.`);
    }
    super(Object.assign({ readableObjectMode: true }, options));
    this.encoder = null;
    const lib = Opus;
    if (lib.name === "opusscript") {
      options.application = lib.Encoder.Application[options.application];
    }
    this.encoder = new lib.Encoder(options.rate, options.channels, options.application);
    this._options = options;
    this._required = this._options.frameSize * this._options.channels * 2;
  }
  _encode(buffer) {
    if (Opus.name === "opusscript") {
      return this.encoder.encode(buffer, this._options.frameSize);
    } else {
      return this.encoder.encode(buffer);
    }
  }
  _decode(buffer) {
    if (Opus.name === "opusscript") {
      return this.encoder.decode(buffer, this._options.frameSize);
    } else {
      return this.encoder.decode(buffer);
    }
  }
  static get type() {
    return Opus.name;
  }
  setBitrate(bitrate) {
    (this.encoder.applyEncoderCTL || this.encoder.encoderCTL).apply(this.encoder, [CTL.BITRATE, Math.min(128e3, Math.max(16e3, bitrate))]);
  }
  setFEC(enabled) {
    (this.encoder.applyEncoderCTL || this.encoder.encoderCTL).apply(this.encoder, [CTL.FEC, enabled ? 1 : 0]);
  }
  setPLP(percentage) {
    (this.encoder.applyEncoderCTL || this.encoder.encoderCTL).apply(this.encoder, [CTL.PLP, Math.min(100, Math.max(0, percentage * 100))]);
  }
  _final(cb) {
    this._cleanup();
    cb();
  }
  _destroy(err, cb) {
    this._cleanup();
    return cb ? cb(err) : void 0;
  }
  _cleanup() {
    if (typeof this.encoder?.delete === "function")
      this.encoder.delete();
    this.encoder = null;
  }
};
__name(OpusStream, "OpusStream");
var OpusEncoder = class extends OpusStream {
  constructor(options = {}) {
    super(options);
    this._buffer = Buffer.allocUnsafe(0);
  }
  _transform(newChunk, encoding, done) {
    const chunk = Buffer.concat([this._buffer, newChunk]);
    let i = 0;
    while (chunk.length >= i + this._required) {
      const pcm = chunk.slice(i, i + this._required);
      let opus;
      try {
        opus = this.encoder.encode(pcm);
      } catch (error) {
        done(error);
        return;
      }
      this.push(opus);
      i += this._required;
    }
    if (i > 0)
      this._buffer = chunk.slice(i);
    done();
  }
  _destroy(err, cb) {
    super._destroy(err, cb);
    this._buffer = Buffer.allocUnsafe(0);
  }
};
__name(OpusEncoder, "OpusEncoder");
var OpusDecoder = class extends OpusStream {
  _transform(chunk, encoding, done) {
    const signature = chunk.slice(0, 8);
    if (chunk.length >= 8 && signature.equals(OPUS_HEAD)) {
      this.emit("format", {
        channels: this._options.channels,
        sampleRate: this._options.rate,
        bitDepth: 16,
        float: false,
        signed: true,
        version: chunk.readUInt8(8),
        preSkip: chunk.readUInt16LE(10),
        gain: chunk.readUInt16LE(16)
      });
      return done();
    }
    if (chunk.length >= 8 && signature.equals(OPUS_TAGS)) {
      this.emit("tags", chunk);
      return done();
    }
    try {
      this.push(this._decode(chunk));
    } catch (e) {
      return done(e);
    }
    return done();
  }
};
__name(OpusDecoder, "OpusDecoder");
var version = "0.1.2";
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  CTL,
  OPUS_MOD_REGISTRY,
  OpusDecoder,
  OpusEncoder,
  OpusStream,
  version
});
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vc3JjL2luZGV4LnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vYW1pc2hzaGFoL3ByaXNtLW1lZGlhL2Jsb2IvNGVmMWQ2ZjlmNTMwNDJjMDg1YzFmNjg2MjdlODg5MDAzZTI0OGQ3Ny9zcmMvb3B1cy9PcHVzLmpzXG5cbmltcG9ydCB7IFRyYW5zZm9ybSwgdHlwZSBUcmFuc2Zvcm1DYWxsYmFjayB9IGZyb20gJ3N0cmVhbSc7XG5cbmV4cG9ydCB0eXBlIElFbmNvZGVyID0ge1xuICAgIG5ldyAocmF0ZTogbnVtYmVyLCBjaGFubmVsczogbnVtYmVyLCBhcHBsaWNhdGlvbjogbnVtYmVyKToge1xuICAgICAgICBlbmNvZGUoYnVmZmVyOiBCdWZmZXIpOiBCdWZmZXI7XG4gICAgICAgIGVuY29kZShidWZmZXI6IEJ1ZmZlciwgZnJhbWVTaXplOiBudW1iZXIpOiBCdWZmZXI7XG4gICAgICAgIGVuY29kZShidWZmZXI6IEJ1ZmZlciwgZnJhbWVTaXplPzogbnVtYmVyKTogQnVmZmVyO1xuICAgICAgICBkZWNvZGUoYnVmZmVyOiBCdWZmZXIpOiBCdWZmZXI7XG4gICAgICAgIGRlY29kZShidWZmZXI6IEJ1ZmZlciwgZnJhbWVTaXplOiBudW1iZXIpOiBCdWZmZXI7XG4gICAgICAgIGRlY29kZShidWZmZXI6IEJ1ZmZlciwgZnJhbWVTaXplPzogbnVtYmVyKTogQnVmZmVyO1xuICAgICAgICBhcHBseUVuY29kZXJDVEw/KGN0bDogbnVtYmVyLCB2YWx1ZTogbnVtYmVyKTogdm9pZDtcbiAgICAgICAgZW5jb2RlckNUTD8oY3RsOiBudW1iZXIsIHZhbHVlOiBudW1iZXIpOiB2b2lkO1xuICAgICAgICBkZWxldGU/KCk6IHZvaWQ7XG4gICAgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIEFwcGxpY2F0aW9uPzogYW55O1xufTtcblxudHlwZSBJTW9kID0gW1xuICAgIHN0cmluZyxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIChtb2Q6IGFueSkgPT4ge1xuICAgICAgICBFbmNvZGVyOiBJRW5jb2RlcjtcbiAgICB9XG5dO1xuXG5jb25zdCBsb2FkTW9kdWxlID0gKFxuICAgIG1vZHVsZXM6IElNb2RbXVxuKToge1xuICAgIEVuY29kZXI6IElFbmNvZGVyO1xuICAgIG5hbWU6IHN0cmluZztcbn0gPT4ge1xuICAgIGNvbnN0IGVycm9yczogc3RyaW5nW10gPSBbXTtcblxuICAgIGZvciAoY29uc3QgW25hbWUsIGZuXSBvZiBtb2R1bGVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzXG4gICAgICAgICAgICAgICAgLi4uZm4ocmVxdWlyZShuYW1lKSksXG4gICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goYEZhaWxlZCB0byBsb2FkICR7bmFtZX06ICR7ZX1gKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgbG9hZCBvcHVzIG1vZHVsZSwgdHJpZWQgJHttb2R1bGVzLmxlbmd0aH0gZGlmZmVyZW50IG1vZHVsZXMuIEVycm9yczogJHtlcnJvcnMuam9pbignXFxuJyl9YCk7XG59O1xuXG5leHBvcnQgY29uc3QgQ1RMID0ge1xuICAgIEJJVFJBVEU6IDB4ZmEyLFxuICAgIEZFQzogMHhmYWMsXG4gICAgUExQOiAweGZhZVxufSBhcyBjb25zdDtcblxuZXhwb3J0IGNvbnN0IE9QVVNfTU9EX1JFR0lTVFJZOiBJTW9kW10gPSBbXG4gICAgW1xuICAgICAgICAnbWVkaWFwbGV4JyxcbiAgICAgICAgKG1vZCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFtb2QuT3B1c0VuY29kZXIpIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgbWVkaWFwbGV4IHZlcnNpb24nKTtcbiAgICAgICAgICAgIHJldHVybiB7IEVuY29kZXI6IG1vZC5PcHVzRW5jb2RlciB9O1xuICAgICAgICB9XG4gICAgXSxcbiAgICBbJ0BkaXNjb3JkanMvb3B1cycsIChvcHVzKSA9PiAoeyBFbmNvZGVyOiBvcHVzLk9wdXNFbmNvZGVyIH0pXSxcbiAgICBbJ29wdXNzY3JpcHQnLCAob3B1cykgPT4gKHsgRW5jb2Rlcjogb3B1cyB9KV0sXG4gICAgW1xuICAgICAgICAnQGV2YW4vb3B1cycsXG4gICAgICAgIChvcHVzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IEVuY29kZXIsIERlY29kZXIgfSA9IG9wdXMgYXMgdHlwZW9mIGltcG9ydCgnQGV2YW4vb3B1cycpO1xuXG4gICAgICAgICAgICBjbGFzcyBPcHVzRW5jb2RlciB7XG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBfZW5jb2RlciE6IEluc3RhbmNlVHlwZTx0eXBlb2YgRW5jb2Rlcj4gfCBudWxsO1xuICAgICAgICAgICAgICAgIHByaXZhdGUgX2RlY29kZXIhOiBJbnN0YW5jZVR5cGU8dHlwZW9mIERlY29kZXI+IHwgbnVsbDtcblxuICAgICAgICAgICAgICAgIHB1YmxpYyBjb25zdHJ1Y3Rvcihwcml2YXRlIF9yYXRlOiBudW1iZXIsIHByaXZhdGUgX2NoYW5uZWxzOiBudW1iZXIsIHByaXZhdGUgX2FwcGxpY2F0aW9uOiBudW1iZXIpIHt9XG5cbiAgICAgICAgICAgICAgICBwcml2YXRlIF9lbnN1cmVFbmNvZGVyKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZW5jb2RlcikgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbmNvZGVyID0gbmV3IEVuY29kZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbHM6IHRoaXMuX2NoYW5uZWxzIGFzIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVfcmF0ZTogdGhpcy5fcmF0ZSBhcyA0ODAwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGxpY2F0aW9uOiAoPGNvbnN0PntcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAyMDQ4OiAndm9pcCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMjA0OTogJ2F1ZGlvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAyMDUxOiAncmVzdHJpY3RlZF9sb3dkZWxheSdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pW3RoaXMuX2FwcGxpY2F0aW9uXVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwcml2YXRlIF9lbnN1cmVEZWNvZGVyKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZGVjb2RlcikgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWNvZGVyID0gbmV3IERlY29kZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbHM6IHRoaXMuX2NoYW5uZWxzIGFzIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVfcmF0ZTogdGhpcy5fcmF0ZSBhcyA0ODAwMFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwdWJsaWMgZW5jb2RlKGJ1ZmZlcjogQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Vuc3VyZUVuY29kZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHRoaXMuX2VuY29kZXIhLmVuY29kZShidWZmZXIpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwdWJsaWMgZGVjb2RlKGJ1ZmZlcjogQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Vuc3VyZURlY29kZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHRoaXMuX2RlY29kZXIhLmRlY29kZShidWZmZXIpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwdWJsaWMgYXBwbHlFbmNvZGVyQ1RMKGN0bDogbnVtYmVyLCB2YWx1ZTogbnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Vuc3VyZUVuY29kZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW5jb2RlciEuY3RsKGN0bCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHB1YmxpYyBkZWxldGUoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VuY29kZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWNvZGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7IEVuY29kZXI6IE9wdXNFbmNvZGVyIH07XG4gICAgICAgIH1cbiAgICBdLFxuICAgIFsnbm9kZS1vcHVzJywgKG9wdXMpID0+ICh7IEVuY29kZXI6IG9wdXMuT3B1c0VuY29kZXIgfSldXG5dO1xuXG5sZXQgT3B1czogeyBFbmNvZGVyPzogSUVuY29kZXI7IG5hbWU/OiBzdHJpbmcgfSA9IHt9O1xuXG5mdW5jdGlvbiBsb2FkT3B1cyhyZWZyZXNoID0gZmFsc2UpIHtcbiAgICBpZiAoT3B1cy5FbmNvZGVyICYmICFyZWZyZXNoKSByZXR1cm4gT3B1cztcblxuICAgIE9wdXMgPSBsb2FkTW9kdWxlKE9QVVNfTU9EX1JFR0lTVFJZKTtcbiAgICByZXR1cm4gT3B1cztcbn1cblxuY29uc3QgY2hhckNvZGUgPSAoeDogc3RyaW5nKSA9PiB4LmNoYXJDb2RlQXQoMCk7XG5jb25zdCBPUFVTX0hFQUQgPSBCdWZmZXIuZnJvbShbLi4uJ09wdXNIZWFkJ10ubWFwKGNoYXJDb2RlKSk7XG5jb25zdCBPUFVTX1RBR1MgPSBCdWZmZXIuZnJvbShbLi4uJ09wdXNUYWdzJ10ubWFwKGNoYXJDb2RlKSk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSU9wdXNTdHJlYW1Jbml0IHtcbiAgICBmcmFtZVNpemU6IG51bWJlcjtcbiAgICBjaGFubmVsczogbnVtYmVyO1xuICAgIHJhdGU6IG51bWJlcjtcbiAgICBhcHBsaWNhdGlvbj86IG51bWJlcjtcbn1cblxuLy8gZnJhbWUgc2l6ZSA9IChjaGFubmVscyAqIHJhdGUgKiBmcmFtZV9kdXJhdGlvbikgLyAxMDAwXG5cbi8qKlxuICogVGFrZXMgYSBzdHJlYW0gb2YgT3B1cyBkYXRhIGFuZCBvdXRwdXRzIGEgc3RyZWFtIG9mIFBDTSBkYXRhLCBvciB0aGUgaW52ZXJzZS5cbiAqICoqWW91IHNob3VsZG4ndCBkaXJlY3RseSBpbnN0YW50aWF0ZSB0aGlzIGNsYXNzLCBzZWUgb3B1cy5FbmNvZGVyIGFuZCBvcHVzLkRlY29kZXIgaW5zdGVhZCEqKlxuICogQG1lbWJlcm9mIG9wdXNcbiAqIEBleHRlbmRzIFRyYW5zZm9ybVN0cmVhbVxuICogQHByb3RlY3RlZFxuICovXG5leHBvcnQgY2xhc3MgT3B1c1N0cmVhbSBleHRlbmRzIFRyYW5zZm9ybSB7XG4gICAgcHVibGljIGVuY29kZXI6IEluc3RhbmNlVHlwZTxJRW5jb2Rlcj4gfCBudWxsID0gbnVsbDtcbiAgICBwdWJsaWMgX29wdGlvbnM6IElPcHVzU3RyZWFtSW5pdDtcbiAgICBwdWJsaWMgX3JlcXVpcmVkOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBPcHVzIHRyYW5zZm9ybWVyLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1lbWJlcm9mIG9wdXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbnMgdGhhdCB5b3Ugd291bGQgcGFzcyB0byBhIHJlZ3VsYXIgVHJhbnNmb3JtIHN0cmVhbVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSBhcyBJT3B1c1N0cmVhbUluaXQpIHtcbiAgICAgICAgaWYgKCFsb2FkT3B1cygpLkVuY29kZXIpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBDb3VsZCBub3QgZmluZCBhbiBPcHVzIG1vZHVsZSEgUGxlYXNlIGluc3RhbGwgb25lIG9mICR7T1BVU19NT0RfUkVHSVNUUlkubWFwKChvKSA9PiBvWzBdKS5qb2luKCcsICcpfS5gKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihPYmplY3QuYXNzaWduKHsgcmVhZGFibGVPYmplY3RNb2RlOiB0cnVlIH0sIG9wdGlvbnMpKTtcblxuICAgICAgICBjb25zdCBsaWIgPSBPcHVzIGFzIFJlcXVpcmVkPHR5cGVvZiBPcHVzPjtcblxuICAgICAgICBpZiAobGliLm5hbWUgPT09ICdvcHVzc2NyaXB0Jykge1xuICAgICAgICAgICAgb3B0aW9ucy5hcHBsaWNhdGlvbiA9IGxpYi5FbmNvZGVyLkFwcGxpY2F0aW9uIVtvcHRpb25zLmFwcGxpY2F0aW9uIV07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVuY29kZXIgPSBuZXcgbGliLkVuY29kZXIob3B0aW9ucy5yYXRlLCBvcHRpb25zLmNoYW5uZWxzLCBvcHRpb25zLmFwcGxpY2F0aW9uISk7XG5cbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVkID0gdGhpcy5fb3B0aW9ucy5mcmFtZVNpemUgKiB0aGlzLl9vcHRpb25zLmNoYW5uZWxzICogMjtcbiAgICB9XG5cbiAgICBfZW5jb2RlKGJ1ZmZlcjogQnVmZmVyKSB7XG4gICAgICAgIGlmIChPcHVzLm5hbWUgPT09ICdvcHVzc2NyaXB0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlciEuZW5jb2RlKGJ1ZmZlciwgdGhpcy5fb3B0aW9ucy5mcmFtZVNpemUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlciEuZW5jb2RlKGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZGVjb2RlKGJ1ZmZlcjogQnVmZmVyKSB7XG4gICAgICAgIGlmIChPcHVzLm5hbWUgPT09ICdvcHVzc2NyaXB0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlciEuZGVjb2RlKGJ1ZmZlciwgdGhpcy5fb3B0aW9ucy5mcmFtZVNpemUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlciEuZGVjb2RlKGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBPcHVzIG1vZHVsZSBiZWluZyB1c2VkIC0gYG1lZGlhcGxleGAsIGBvcHVzc2NyaXB0YCwgYG5vZGUtb3B1c2AsIG9yIGBAZGlzY29yZGpzL29wdXNgLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zb2xlLmxvZyhgVXNpbmcgT3B1cyBtb2R1bGUgJHtwcmlzbS5vcHVzLkVuY29kZXIudHlwZX1gKTtcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBPcHVzLm5hbWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYml0cmF0ZSBvZiB0aGUgc3RyZWFtLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRyYXRlIHRoZSBiaXRyYXRlIHRvIHVzZSB1c2UsIGUuZy4gNDgwMDBcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgc2V0Qml0cmF0ZShiaXRyYXRlOiBudW1iZXIpIHtcbiAgICAgICAgKHRoaXMuZW5jb2RlciEuYXBwbHlFbmNvZGVyQ1RMISB8fCB0aGlzLmVuY29kZXIhLmVuY29kZXJDVEwpLmFwcGx5KHRoaXMuZW5jb2RlciEsIFtDVEwuQklUUkFURSwgTWF0aC5taW4oMTI4ZTMsIE1hdGgubWF4KDE2ZTMsIGJpdHJhdGUpKV0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgZm9yd2FyZCBlcnJvciBjb3JyZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZCB3aGV0aGVyIG9yIG5vdCB0byBlbmFibGUgRkVDLlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBzZXRGRUMoZW5hYmxlZDogYm9vbGVhbikge1xuICAgICAgICAodGhpcy5lbmNvZGVyIS5hcHBseUVuY29kZXJDVEwhIHx8IHRoaXMuZW5jb2RlciEuZW5jb2RlckNUTCkuYXBwbHkodGhpcy5lbmNvZGVyISwgW0NUTC5GRUMsIGVuYWJsZWQgPyAxIDogMF0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGV4cGVjdGVkIHBhY2tldCBsb3NzIG92ZXIgbmV0d29yayB0cmFuc21pc3Npb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwZXJjZW50YWdlXSBhIHBlcmNlbnRhZ2UgKHJlcHJlc2VudGVkIGJldHdlZW4gMCBhbmQgMSlcbiAgICAgKi9cbiAgICBzZXRQTFAocGVyY2VudGFnZTogbnVtYmVyKSB7XG4gICAgICAgICh0aGlzLmVuY29kZXIhLmFwcGx5RW5jb2RlckNUTCEgfHwgdGhpcy5lbmNvZGVyIS5lbmNvZGVyQ1RMKS5hcHBseSh0aGlzLmVuY29kZXIhLCBbQ1RMLlBMUCwgTWF0aC5taW4oMTAwLCBNYXRoLm1heCgwLCBwZXJjZW50YWdlICogMTAwKSldKTtcbiAgICB9XG5cbiAgICBfZmluYWwoY2I6ICgpID0+IHZvaWQpIHtcbiAgICAgICAgdGhpcy5fY2xlYW51cCgpO1xuICAgICAgICBjYigpO1xuICAgIH1cblxuICAgIF9kZXN0cm95KGVycjogRXJyb3IgfCBudWxsLCBjYjogKGVycjogRXJyb3IgfCBudWxsKSA9PiB2b2lkKSB7XG4gICAgICAgIHRoaXMuX2NsZWFudXAoKTtcbiAgICAgICAgcmV0dXJuIGNiID8gY2IoZXJyKSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhbnMgdXAgdGhlIE9wdXMgc3RyZWFtIHdoZW4gaXQgaXMgbm8gbG9uZ2VyIG5lZWRlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NsZWFudXAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5lbmNvZGVyPy5kZWxldGUgPT09ICdmdW5jdGlvbicpIHRoaXMuZW5jb2RlciEuZGVsZXRlISgpO1xuICAgICAgICB0aGlzLmVuY29kZXIgPSBudWxsO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBbiBPcHVzIGVuY29kZXIgc3RyZWFtLlxuICpcbiAqIE91dHB1dHMgb3B1cyBwYWNrZXRzIGluIFtvYmplY3QgbW9kZS5dKGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvc3RyZWFtLmh0bWwjc3RyZWFtX29iamVjdF9tb2RlKVxuICogQGV4dGVuZHMgb3B1cy5PcHVzU3RyZWFtXG4gKiBAbWVtYmVyb2Ygb3B1c1xuICogQGV4YW1wbGVcbiAqIGNvbnN0IGVuY29kZXIgPSBuZXcgcHJpc20ub3B1cy5FbmNvZGVyKHsgZnJhbWVTaXplOiA5NjAsIGNoYW5uZWxzOiAyLCByYXRlOiA0ODAwMCB9KTtcbiAqIHBjbUF1ZGlvLnBpcGUoZW5jb2Rlcik7XG4gKiAvLyBlbmNvZGVyIHdpbGwgbm93IG91dHB1dCBPcHVzLWVuY29kZWQgYXVkaW8gcGFja2V0c1xuICovXG5leHBvcnQgY2xhc3MgT3B1c0VuY29kZXIgZXh0ZW5kcyBPcHVzU3RyZWFtIHtcbiAgICBfYnVmZmVyOiBCdWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMCk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IE9wdXMgZW5jb2RlciBzdHJlYW0uXG4gICAgICogQG1lbWJlcm9mIG9wdXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBvcHRpb25zIHRoYXQgeW91IHdvdWxkIHBhc3MgdG8gYSByZWd1bGFyIE9wdXNTdHJlYW0sIHBsdXMgYSBmZXcgbW9yZTpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5mcmFtZVNpemUgdGhlIGZyYW1lIHNpemUgaW4gYnl0ZXMgdG8gdXNlIChlLmcuIDk2MCBmb3Igc3RlcmVvIGF1ZGlvIGF0IDQ4S0h6IHdpdGggYSBmcmFtZVxuICAgICAqIGR1cmF0aW9uIG9mIDIwbXMpXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuY2hhbm5lbHMgdGhlIG51bWJlciBvZiBjaGFubmVscyB0byB1c2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5yYXRlIHRoZSBzYW1wbGluZyByYXRlIGluIEh6XG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9IGFzIElPcHVzU3RyZWFtSW5pdCkge1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgX3RyYW5zZm9ybShuZXdDaHVuazogQnVmZmVyLCBlbmNvZGluZzogQnVmZmVyRW5jb2RpbmcsIGRvbmU6IFRyYW5zZm9ybUNhbGxiYWNrKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGNodW5rID0gQnVmZmVyLmNvbmNhdChbdGhpcy5fYnVmZmVyLCBuZXdDaHVua10pO1xuXG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgd2hpbGUgKGNodW5rLmxlbmd0aCA+PSBpICsgdGhpcy5fcmVxdWlyZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBjbSA9IGNodW5rLnNsaWNlKGksIGkgKyB0aGlzLl9yZXF1aXJlZCk7XG4gICAgICAgICAgICBsZXQgb3B1czogQnVmZmVyIHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBvcHVzID0gdGhpcy5lbmNvZGVyIS5lbmNvZGUocGNtKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgZG9uZShlcnJvciBhcyBFcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wdXNoKG9wdXMpO1xuICAgICAgICAgICAgaSArPSB0aGlzLl9yZXF1aXJlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpID4gMCkgdGhpcy5fYnVmZmVyID0gY2h1bmsuc2xpY2UoaSk7XG4gICAgICAgIGRvbmUoKTtcbiAgICB9XG5cbiAgICBfZGVzdHJveShlcnI6IEVycm9yLCBjYjogKGVycjogRXJyb3IgfCBudWxsKSA9PiB2b2lkKSB7XG4gICAgICAgIHN1cGVyLl9kZXN0cm95KGVyciwgY2IpO1xuICAgICAgICB0aGlzLl9idWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEFuIE9wdXMgZGVjb2RlciBzdHJlYW0uXG4gKlxuICogTm90ZSB0aGF0IGFueSBzdHJlYW0geW91IHBpcGUgaW50byB0aGlzIG11c3QgYmUgaW5cbiAqIFtvYmplY3QgbW9kZV0oaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9zdHJlYW0uaHRtbCNzdHJlYW1fb2JqZWN0X21vZGUpIGFuZCBzaG91bGQgb3V0cHV0IE9wdXMgcGFja2V0cy5cbiAqIEBleHRlbmRzIG9wdXMuT3B1c1N0cmVhbVxuICogQG1lbWJlcm9mIG9wdXNcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBkZWNvZGVyID0gbmV3IHByaXNtLm9wdXMuRGVjb2Rlcih7IGZyYW1lU2l6ZTogOTYwLCBjaGFubmVsczogMiwgcmF0ZTogNDgwMDAgfSk7XG4gKiBpbnB1dC5waXBlKGRlY29kZXIpO1xuICogLy8gZGVjb2RlciB3aWxsIG5vdyBvdXRwdXQgUENNIGF1ZGlvXG4gKi9cbmV4cG9ydCBjbGFzcyBPcHVzRGVjb2RlciBleHRlbmRzIE9wdXNTdHJlYW0ge1xuICAgIF90cmFuc2Zvcm0oY2h1bms6IEJ1ZmZlciwgZW5jb2Rpbmc6IEJ1ZmZlckVuY29kaW5nLCBkb25lOiAoZT86IEVycm9yIHwgbnVsbCwgY2h1bms/OiBCdWZmZXIpID0+IHZvaWQpIHtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gY2h1bmsuc2xpY2UoMCwgOCk7XG4gICAgICAgIGlmIChjaHVuay5sZW5ndGggPj0gOCAmJiBzaWduYXR1cmUuZXF1YWxzKE9QVVNfSEVBRCkpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZm9ybWF0Jywge1xuICAgICAgICAgICAgICAgIGNoYW5uZWxzOiB0aGlzLl9vcHRpb25zLmNoYW5uZWxzLFxuICAgICAgICAgICAgICAgIHNhbXBsZVJhdGU6IHRoaXMuX29wdGlvbnMucmF0ZSxcbiAgICAgICAgICAgICAgICBiaXREZXB0aDogMTYsXG4gICAgICAgICAgICAgICAgZmxvYXQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNpZ25lZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBjaHVuay5yZWFkVUludDgoOCksXG4gICAgICAgICAgICAgICAgcHJlU2tpcDogY2h1bmsucmVhZFVJbnQxNkxFKDEwKSxcbiAgICAgICAgICAgICAgICBnYWluOiBjaHVuay5yZWFkVUludDE2TEUoMTYpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNodW5rLmxlbmd0aCA+PSA4ICYmIHNpZ25hdHVyZS5lcXVhbHMoT1BVU19UQUdTKSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCd0YWdzJywgY2h1bmspO1xuICAgICAgICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5wdXNoKHRoaXMuX2RlY29kZShjaHVuaykpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9uZShlIGFzIEVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgIH1cbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1pbmZlcnJhYmxlLXR5cGVzXG5leHBvcnQgY29uc3QgdmVyc2lvbjogc3RyaW5nID0gJzAuMS4yJztcbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUEsb0JBQWtEO0FBMEJsRCxJQUFNLGFBQWEsd0JBQ2YsWUFJQztBQUNELFFBQU0sU0FBbUIsQ0FBQztBQUUxQixhQUFXLENBQUMsTUFBTSxFQUFFLEtBQUssU0FBUztBQUM5QixRQUFJO0FBQ0EsYUFBTztBQUFBLFFBRUgsR0FBRyxHQUFHLFFBQVEsS0FBSztBQUFBLFFBQ25CO0FBQUEsTUFDSjtBQUFBLElBQ0osU0FBUyxHQUFQO0FBQ0UsYUFBTyxLQUFLLGtCQUFrQixTQUFTLEdBQUc7QUFDMUM7QUFBQSxJQUNKO0FBQUEsRUFDSjtBQUVBLFFBQU0sSUFBSSxNQUFNLHFDQUFxQyxRQUFRLHFDQUFxQyxPQUFPLEtBQUssSUFBSSxHQUFHO0FBQ3pILEdBdEJtQjtBQXdCWixJQUFNLE1BQU07QUFBQSxFQUNmLFNBQVM7QUFBQSxFQUNULEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFDVDtBQUVPLElBQU0sb0JBQTRCO0FBQUEsRUFDckM7QUFBQSxJQUNJO0FBQUEsSUFDQSxDQUFDLFFBQVE7QUFDTCxVQUFJLENBQUMsSUFBSTtBQUFhLGNBQU0sSUFBSSxNQUFNLCtCQUErQjtBQUNyRSxhQUFPLEVBQUUsU0FBUyxJQUFJLFlBQVk7QUFBQSxJQUN0QztBQUFBLEVBQ0o7QUFBQSxFQUNBLENBQUMsbUJBQW1CLENBQUMsVUFBVSxFQUFFLFNBQVMsS0FBSyxZQUFZLEVBQUU7QUFBQSxFQUM3RCxDQUFDLGNBQWMsQ0FBQyxVQUFVLEVBQUUsU0FBUyxLQUFLLEVBQUU7QUFBQSxFQUM1QztBQUFBLElBQ0k7QUFBQSxJQUNBLENBQUMsU0FBUztBQUNOLFlBQU0sRUFBRSxTQUFTLFFBQVEsSUFBSTtBQUU3QixZQUFNQSxhQUFZO0FBQUEsUUFJUCxZQUFvQixPQUF1QixXQUEyQixjQUFzQjtBQUF4RTtBQUF1QjtBQUEyQjtBQUFBLFFBQXVCO0FBQUEsUUFFNUYsaUJBQWlCO0FBQ3JCLGNBQUksS0FBSztBQUFVO0FBQ25CLGVBQUssV0FBVyxJQUFJLFFBQVE7QUFBQSxZQUN4QixVQUFVLEtBQUs7QUFBQSxZQUNmLGFBQWEsS0FBSztBQUFBLFlBQ2xCLGFBQXFCO0FBQUEsY0FDakIsTUFBTTtBQUFBLGNBQ04sTUFBTTtBQUFBLGNBQ04sTUFBTTtBQUFBLFlBQ1YsRUFBRyxLQUFLO0FBQUEsVUFDWixDQUFDO0FBQUEsUUFDTDtBQUFBLFFBRVEsaUJBQWlCO0FBQ3JCLGNBQUksS0FBSztBQUFVO0FBQ25CLGVBQUssV0FBVyxJQUFJLFFBQVE7QUFBQSxZQUN4QixVQUFVLEtBQUs7QUFBQSxZQUNmLGFBQWEsS0FBSztBQUFBLFVBQ3RCLENBQUM7QUFBQSxRQUNMO0FBQUEsUUFFTyxPQUFPLFFBQWdCO0FBQzFCLGVBQUssZUFBZTtBQUNwQixpQkFBTyxPQUFPLEtBQUssS0FBSyxTQUFVLE9BQU8sTUFBTSxDQUFDO0FBQUEsUUFDcEQ7QUFBQSxRQUVPLE9BQU8sUUFBZ0I7QUFDMUIsZUFBSyxlQUFlO0FBQ3BCLGlCQUFPLE9BQU8sS0FBSyxLQUFLLFNBQVUsT0FBTyxNQUFNLENBQUM7QUFBQSxRQUNwRDtBQUFBLFFBRU8sZ0JBQWdCLEtBQWEsT0FBZTtBQUMvQyxlQUFLLGVBQWU7QUFDcEIsZUFBSyxTQUFVLElBQUksS0FBSyxLQUFLO0FBQUEsUUFDakM7QUFBQSxRQUVPLFNBQVM7QUFDWixlQUFLLFdBQVc7QUFDaEIsZUFBSyxXQUFXO0FBQUEsUUFDcEI7QUFBQSxNQUNKO0FBOUNNLGFBQUFBLGNBQUE7QUFnRE4sYUFBTyxFQUFFLFNBQVNBLGFBQVk7QUFBQSxJQUNsQztBQUFBLEVBQ0o7QUFBQSxFQUNBLENBQUMsYUFBYSxDQUFDLFVBQVUsRUFBRSxTQUFTLEtBQUssWUFBWSxFQUFFO0FBQzNEO0FBRUEsSUFBSSxPQUE4QyxDQUFDO0FBRW5ELFNBQVMsU0FBUyxVQUFVLE9BQU87QUFDL0IsTUFBSSxLQUFLLFdBQVcsQ0FBQztBQUFTLFdBQU87QUFFckMsU0FBTyxXQUFXLGlCQUFpQjtBQUNuQyxTQUFPO0FBQ1g7QUFMUztBQU9ULElBQU0sV0FBVyx3QkFBQyxNQUFjLEVBQUUsV0FBVyxDQUFDLEdBQTdCO0FBQ2pCLElBQU0sWUFBWSxPQUFPLEtBQUssQ0FBQyxHQUFHLFVBQVUsRUFBRSxJQUFJLFFBQVEsQ0FBQztBQUMzRCxJQUFNLFlBQVksT0FBTyxLQUFLLENBQUMsR0FBRyxVQUFVLEVBQUUsSUFBSSxRQUFRLENBQUM7QUFrQnBELElBQU0sYUFBTixjQUF5Qix3QkFBVTtBQUFBLEVBVXRDLFlBQVksVUFBVSxDQUFDLEdBQXNCO0FBQ3pDLFFBQUksQ0FBQyxTQUFTLEVBQUUsU0FBUztBQUNyQixZQUFNLE1BQU0sd0RBQXdELGtCQUFrQixJQUFJLENBQUMsTUFBTSxFQUFFLEVBQUUsRUFBRSxLQUFLLElBQUksSUFBSTtBQUFBLElBQ3hIO0FBQ0EsVUFBTSxPQUFPLE9BQU8sRUFBRSxvQkFBb0IsS0FBSyxHQUFHLE9BQU8sQ0FBQztBQWI5RCxTQUFPLFVBQXlDO0FBZTVDLFVBQU0sTUFBTTtBQUVaLFFBQUksSUFBSSxTQUFTLGNBQWM7QUFDM0IsY0FBUSxjQUFjLElBQUksUUFBUSxZQUFhLFFBQVE7QUFBQSxJQUMzRDtBQUVBLFNBQUssVUFBVSxJQUFJLElBQUksUUFBUSxRQUFRLE1BQU0sUUFBUSxVQUFVLFFBQVEsV0FBWTtBQUVuRixTQUFLLFdBQVc7QUFDaEIsU0FBSyxZQUFZLEtBQUssU0FBUyxZQUFZLEtBQUssU0FBUyxXQUFXO0FBQUEsRUFDeEU7QUFBQSxFQUVBLFFBQVEsUUFBZ0I7QUFDcEIsUUFBSSxLQUFLLFNBQVMsY0FBYztBQUM1QixhQUFPLEtBQUssUUFBUyxPQUFPLFFBQVEsS0FBSyxTQUFTLFNBQVM7QUFBQSxJQUMvRCxPQUFPO0FBQ0gsYUFBTyxLQUFLLFFBQVMsT0FBTyxNQUFNO0FBQUEsSUFDdEM7QUFBQSxFQUNKO0FBQUEsRUFFQSxRQUFRLFFBQWdCO0FBQ3BCLFFBQUksS0FBSyxTQUFTLGNBQWM7QUFDNUIsYUFBTyxLQUFLLFFBQVMsT0FBTyxRQUFRLEtBQUssU0FBUyxTQUFTO0FBQUEsSUFDL0QsT0FBTztBQUNILGFBQU8sS0FBSyxRQUFTLE9BQU8sTUFBTTtBQUFBLElBQ3RDO0FBQUEsRUFDSjtBQUFBLEVBU0EsV0FBVyxPQUFPO0FBQ2QsV0FBTyxLQUFLO0FBQUEsRUFDaEI7QUFBQSxFQU9BLFdBQVcsU0FBaUI7QUFDeEIsS0FBQyxLQUFLLFFBQVMsbUJBQW9CLEtBQUssUUFBUyxZQUFZLE1BQU0sS0FBSyxTQUFVLENBQUMsSUFBSSxTQUFTLEtBQUssSUFBSSxPQUFPLEtBQUssSUFBSSxNQUFNLE9BQU8sQ0FBQyxDQUFDLENBQUM7QUFBQSxFQUM3STtBQUFBLEVBT0EsT0FBTyxTQUFrQjtBQUNyQixLQUFDLEtBQUssUUFBUyxtQkFBb0IsS0FBSyxRQUFTLFlBQVksTUFBTSxLQUFLLFNBQVUsQ0FBQyxJQUFJLEtBQUssVUFBVSxJQUFJLENBQUMsQ0FBQztBQUFBLEVBQ2hIO0FBQUEsRUFNQSxPQUFPLFlBQW9CO0FBQ3ZCLEtBQUMsS0FBSyxRQUFTLG1CQUFvQixLQUFLLFFBQVMsWUFBWSxNQUFNLEtBQUssU0FBVSxDQUFDLElBQUksS0FBSyxLQUFLLElBQUksS0FBSyxLQUFLLElBQUksR0FBRyxhQUFhLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFBQSxFQUM3STtBQUFBLEVBRUEsT0FBTyxJQUFnQjtBQUNuQixTQUFLLFNBQVM7QUFDZCxPQUFHO0FBQUEsRUFDUDtBQUFBLEVBRUEsU0FBUyxLQUFtQixJQUFpQztBQUN6RCxTQUFLLFNBQVM7QUFDZCxXQUFPLEtBQUssR0FBRyxHQUFHLElBQUk7QUFBQSxFQUMxQjtBQUFBLEVBTUEsV0FBVztBQUNQLFFBQUksT0FBTyxLQUFLLFNBQVMsV0FBVztBQUFZLFdBQUssUUFBUyxPQUFRO0FBQ3RFLFNBQUssVUFBVTtBQUFBLEVBQ25CO0FBQ0o7QUFuR2E7QUFnSE4sSUFBTSxjQUFOLGNBQTBCLFdBQVc7QUFBQSxFQVl4QyxZQUFZLFVBQVUsQ0FBQyxHQUFzQjtBQUN6QyxVQUFNLE9BQU87QUFaakIsbUJBQWtCLE9BQU8sWUFBWSxDQUFDO0FBQUEsRUFhdEM7QUFBQSxFQUVPLFdBQVcsVUFBa0IsVUFBMEIsTUFBK0I7QUFDekYsVUFBTSxRQUFRLE9BQU8sT0FBTyxDQUFDLEtBQUssU0FBUyxRQUFRLENBQUM7QUFFcEQsUUFBSSxJQUFJO0FBQ1IsV0FBTyxNQUFNLFVBQVUsSUFBSSxLQUFLLFdBQVc7QUFDdkMsWUFBTSxNQUFNLE1BQU0sTUFBTSxHQUFHLElBQUksS0FBSyxTQUFTO0FBQzdDLFVBQUk7QUFDSixVQUFJO0FBQ0EsZUFBTyxLQUFLLFFBQVMsT0FBTyxHQUFHO0FBQUEsTUFDbkMsU0FBUyxPQUFQO0FBQ0UsYUFBSyxLQUFjO0FBQ25CO0FBQUEsTUFDSjtBQUNBLFdBQUssS0FBSyxJQUFJO0FBQ2QsV0FBSyxLQUFLO0FBQUEsSUFDZDtBQUVBLFFBQUksSUFBSTtBQUFHLFdBQUssVUFBVSxNQUFNLE1BQU0sQ0FBQztBQUN2QyxTQUFLO0FBQUEsRUFDVDtBQUFBLEVBRUEsU0FBUyxLQUFZLElBQWlDO0FBQ2xELFVBQU0sU0FBUyxLQUFLLEVBQUU7QUFDdEIsU0FBSyxVQUFVLE9BQU8sWUFBWSxDQUFDO0FBQUEsRUFDdkM7QUFDSjtBQXpDYTtBQXVETixJQUFNLGNBQU4sY0FBMEIsV0FBVztBQUFBLEVBQ3hDLFdBQVcsT0FBZSxVQUEwQixNQUFrRDtBQUNsRyxVQUFNLFlBQVksTUFBTSxNQUFNLEdBQUcsQ0FBQztBQUNsQyxRQUFJLE1BQU0sVUFBVSxLQUFLLFVBQVUsT0FBTyxTQUFTLEdBQUc7QUFDbEQsV0FBSyxLQUFLLFVBQVU7QUFBQSxRQUNoQixVQUFVLEtBQUssU0FBUztBQUFBLFFBQ3hCLFlBQVksS0FBSyxTQUFTO0FBQUEsUUFDMUIsVUFBVTtBQUFBLFFBQ1YsT0FBTztBQUFBLFFBQ1AsUUFBUTtBQUFBLFFBQ1IsU0FBUyxNQUFNLFVBQVUsQ0FBQztBQUFBLFFBQzFCLFNBQVMsTUFBTSxhQUFhLEVBQUU7QUFBQSxRQUM5QixNQUFNLE1BQU0sYUFBYSxFQUFFO0FBQUEsTUFDL0IsQ0FBQztBQUNELGFBQU8sS0FBSztBQUFBLElBQ2hCO0FBQ0EsUUFBSSxNQUFNLFVBQVUsS0FBSyxVQUFVLE9BQU8sU0FBUyxHQUFHO0FBQ2xELFdBQUssS0FBSyxRQUFRLEtBQUs7QUFDdkIsYUFBTyxLQUFLO0FBQUEsSUFDaEI7QUFDQSxRQUFJO0FBQ0EsV0FBSyxLQUFLLEtBQUssUUFBUSxLQUFLLENBQUM7QUFBQSxJQUNqQyxTQUFTLEdBQVA7QUFDRSxhQUFPLEtBQUssQ0FBVTtBQUFBLElBQzFCO0FBQ0EsV0FBTyxLQUFLO0FBQUEsRUFDaEI7QUFDSjtBQTNCYTtBQThCTixJQUFNLFVBQWtCOyIsCiAgIm5hbWVzIjogWyJPcHVzRW5jb2RlciJdCn0K